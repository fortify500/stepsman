title: "HR approvals"
# optional, but recommended, if in the future we will have breaking changes this allows to migrate on the fly.
version: 1
context:
  namespace: 1524533c-9451-463d-be42-a186f3dfe5dd
  object-id: f845cbf3-0585-46ff-9656-0fce4a0de38e
on:
  error:
    rules:
      - if: >
          result{input.error["phrase"]=="run-expired"}
        then:
          do:
            - label: expiration
steps:
  - name: "expiration"
    description: expire the workflow
    label: expiration
    on:
      done:
        rules:
          - then:
              do:
                - label: report_run_result
                  context: >
                    { "result": "expired"}
  - name: "send emails to step path_1_step_1"
    description: >
      Send email by given step
    label: path_1_step_1_email
    do:
      type: REST
      heartbeat-timeout: 180 # seconds. default 10. 
      options:
        timeout: 60 #seconds
        method: GET
        url: >-
          {% input.context.url %}/send-emails/path_1_step_1
        headers:
          authorization:
            - >-
              {% base64.encode(concat("privilegedUser:",  input.context["emails-password"])) %}
          tenant:
            - >-
              {% input.context["tenant"] %}
          namespace:
            - >-
              {% input.context["namespace"] %}
  - name: "Path 1 Step 1: role A"
    label: path_1_step_1
    description: >
      this will be called as an event. I.e. we are awaiting for an external call (rest,command line etc...).
    context:
      allowed-approval:
        - b2e7ffb8-4d38-4d34-be80-126c532836b0
        - d10ae63f-b85f-4ea0-9e31-8937c3af3450
      allowed-skip:
        - b2e7ffb8-4d38-4d34-be80-126c532836b0
        - d10ae63f-b85f-4ea0-9e31-8937c3af3450
    do:
      type: evaluate
      options:
        - then:
            set-result: >
              {"status":{% input.context["status"] %}}
    on:
      in-progress: #important to note that in-progress is decided before locking the step into one execution of DO (i.e. in-progress status)
        decisions:
          - label: check_access
          - label: check_valid_input
            input: >
              { "step_input": "{% input.request["data"]["status"] %}" }
        rules:
          - if: >
              result{input.decision["check_access"]["result"]=="denied"}
            then:
              error:
                code: 403
                message: "access denied"
                data: >
                  {% input.decision["check_access"]["result"] %}
          - if: >
              result{input.decision["check_valid_input"]["result"]!="valid"}
            then:
              error:
                code: 400
                message: "invalid input"
                data: >
                  {% input.decision["check_valid_input"]["result"] %}
      done:
        decisions:
          - label: decision_step
            input: >
              step_status:=label["status"]
        rules:
          - if: >
              result{input.decision["decision_step"]["result"]="approved"}
            then:
              do:
                - label: path_1_step_2_email
                  context: >
                    {% object.union(input.context,{"step":"path_1_step_2"}) %}
          - then:
              do:
                - label: report_run_result
                  context: >
                    { "result": "declined"}
  - name: "send emails to step path_1_step_2"
    description: >
      Send email by given step
    label: path_1_step_2_email
    do:
      type: REST # 201 with heartbeats of set InProgress and finally set Done.
      heartbeat-timeout: 180 # seconds. default 10. 
      options:
        timeout: 60
        method: GET
        url: >-
          {% input.context.url %}/send-emails/path_1_step_2
        headers:
          authorization:
            - >-
              {% base64.encode(concat("privilegedUser:",  input.context["emails-password"])) %}
          tenant:
            - >-
              {% input.context["tenant"] %}
          namespace:
            - >-
              {% input.context["namespace"] %}
  - name: "Path 1 Step 2: role B"
    description: >
      this will be called as an event. I.e. we are awaiting for an external call (rest,command line etc...).
    label: path_1_step_2
    context:
      allowed-approval:
        - b2e7ffb8-4d38-4d34-be80-126c532836b0
        - d10ae63f-b85f-4ea0-9e31-8937c3af3450
      allowed-skip:
        - b2e7ffb8-4d38-4d34-be80-126c532836b0
        - d10ae63f-b85f-4ea0-9e31-8937c3af3450
    do:
      type: evaluate
      options:
        - then:
            set-result: >
              {"status":{% input.context["status"] %}}
    on:
      in-progress:
        decisions:
          - label: check_access
          - label: check_valid_input
            input: >
              { "step_input": "{% input.request["data"]["status"] %}" }
        rules:
          - if: >
              result{input.decision["check_access"]["result"]=="denied"}
            then:
              error:
                code: 403
                message: "access denied"
                data: >
                  {% input.decision["check_access"]["result"] %}
          - if: >
              result{input.decision["check_valid_input"]["result"]!="valid"}
            then:
              error:
                code: 400
                message: "invalid input"
                data: >
                  {% input.decision["check_valid_input"]["result"] %}
      done:
        decisions:
          - label: decision_step
            input: >
              step_status:=label["status"]
        rules:
          - if: >
              result{input.decision["decision_step"]["result"]="approved"}
            then:
              do:
                - label: check_resolution
          - then:
              do:
                - label: report_run_result
                  context: >
                    { "result": "declined"}
  #.... path 2 path3....
  # last path do: report_run_result in the event of approved decision
  - name: Check Resolution
    label: check_resolution
    on:
      in-progress:
        decisions:
          - label: decision_resolution
            input: >
              path_1_step_1:=inputs["labels"]["path_1_step_1"]["status"]
              path_1_step_2:=inputs["labels"]["path_1_step_2"]["status"]
              path_2_step_1:=inputs["labels"]["path_2_step_1"]["status"]
              path_2_step_2:=inputs["labels"]["path_1_step_2"]["status"]
        rules:
          - if: >
              result{
                input.decision["decision_resolution"]["result"]=="approved"
              } else {
                input.decision["decision_resolution"]["result"]=="declined"
              }
            then:
              do:
                - label: report_run_result
                  context: >
                    { "result": {% input.decision["decision_resolution"]["result"] %} }
          - then:
              abort: true #don't continue to "do"
  - name: Report Run Result
    label: report_run_result
    do:
      type: REST
      options:
        method: POST
        url: >
          {% input.context.server_url %}/re_notification
        body: >
          { "result": {% input.context["result"] %} }
        headers:
          authorization:
            - >-
              {% base64.encode(concat("privilegedUser:",  input.context["emails-password"])) %}
          tenant:
            - >-
              {% input.context["tenant"] %}
          namespace:
            - >-
              {% input.context["namespace"] %}
    on:
      done:
        rules:
          - if: >
              result{input.label["report_run_result"]["status"]!=200}
            then:
              set-run-status: done
              error:
                code: 500
                message: "failed"
                data: >
                  {% input.label["report_run_result"]["status"] %}
          - then:
              set: # record this status in the step. label["report_run_result"]["kv"]["result"]
                - key: result
                  value: >
                    {% input.context["result"] %}
              set-run-status: done #once run-status is "done" then no other processes can be executed in the run, and all existing are discarded.

#---------------------------------------------------------
decisions:
  - name: check access
    label: check_access # label must be unique
    rules:
      - if: >
          allowed-roles{input.context["roles"][_]==input.step.context["allowed-approval"][_]}
          result{v:=["approve","decline"];input.context["status"]=v[_];not allowed-roles}
        then:
          result: denied
      - if: >
          allowed-roles{context["roles"][_]==input.step.context["allowed-skipped"][_]}
          result{input.context["status"]="skipped";not allowed-roles}
        then:
          result: denied
  - name: check valid input
    label: check_valid_input
    attributes:
      - label: step_input
        type: flow_status
    rules:
      - then:
          result: valid
  - name: check a step has resolution
    label: decision_step # label must be unique
    attributes: # essentially these are both validation an if necessary type conversion if possible.
      - label: step_status
        type: flow_status
    rules: # the IFs are first one true. we stop.
      - if: >
          result{v:=["skipped","approved"];input.step_status=v[_]}
        then:
          result: approved
      - if: >
          result{input.step_status="declined"}
        then:
          result: declined
  - name: check run has resolution
    label: decision_resolution
    attributes:
      - label: path_1_step_1
        type: flow_status
      - label: path_1_step_2
        type: flow_status
      - label: path_2_step_1
        type: flow_status
      - label: path_2_step_2
        type: flow_status
    dependencies:
      decisions:
        - label: decision_step
          as: path_1_step_1_decision
          input: >
            step_status:=path_1_step_1
        - label: decision_step
          as: path_1_step_2_decision
          input: >
            step_status:=path_1_step_2
        - label: decision_step
          as: path_2_step_1_decision
          input: >
            step_status:=path_2_step_1
        - label: decision_step
          as: path_2_step_2_decision
          input: >
            step_status:=path_2_step_2
    rules:
      - if: >
          result{
            v:=["skipped","approved"]
            input.path_1_step_1_decision["result"]=v[_]
            input.path_1_step_2_decision["result"]=v[_]
            input.path_2_step_1_decision["result"]=v[_]
            input.path_2_step_2_decision["result"]=v[_]
          }
        then:
          result: approved
      - if: >
          result{input.path_1_step_1_decision="declined"}
        then:
          result: declined
      - if: >
          result{input.path_1_step_2_decision="declined"}
        then:
          result: declined
      - if: >
          result{input.path_2_step_1_decision="declined"}
        then:
          result: declined
      - if: >
          result{input.path_2_step_2_decision="declined"}
        then:
          result: declined
concepts: # int64, float64 and string, bool are reserved and need not specified.
  - name: flow_status #unique name
    type: string
    validations:
      - >
        default result=false
        result{input.flow_status=="skipped"}else{input.flow_status=="approved"}else{input.flow_status=="declined"}

# notes:
# * as a convenience a response body is first attempted to be converted to a json. if it does not succeed it is stored as a string in the ["result"]["body"]
# * Vault secrets and properties (such as tenant properties) will be retrieved by default from a static text file or hashicorp vault client.
# * You can access environment variables via "env.".