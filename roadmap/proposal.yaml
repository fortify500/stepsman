title: "namespace HR approvals"
# optional, but recommended, if in the future we will have breaking changes this allows to migrate on the fly.
version: 1
# searchable tags. if you want to locate a template by an external key.
tags:
  uuid:
    - e09d86c4-b907-4674-af4f-8aceeb2b7ef1
steps:
  - name: "expiration" # you can setup a scheduler to call this step after a timeout. alternatively, flow will call this if it detects the timeout has expired on any call/query to it.
    description: expire the workflow
    label: expiration
    on:
      pre-done:
        rules:
          - then:
              do:
                - label: report_run_result
                  context: >
                    { "result": "expired"}
  - name: "send emails to step path_1_step_1"
    description: >
      Send email by given step
    label: path_1_step_1_email
    do:
      type: REST
      heartbeat-timeout: 180 # seconds. default 10. 
      options:
        timeout: 60 #seconds
        method: GET
        url: >
          {{ env.flow}}/send-emails/path_1_step_1
        headers:
          authorization:
            - >
              {{ base64.encode(concat("privilegedUser:",  vault["privilegedUser path"])) }}
          tenant:
            - >
              {{ context["tenant"] }}
          namespace:
            - 351d87f0-9d4a-411b-9a98-7d55a9792eac
  - name: "Path 1 Step 1: role A"
    label: path_1_step_1
    description: >
      this will be called as an event. I.e. we are awaiting for an external call (rest,command line etc...).
    tags:
      allowed-approval:
        - b2e7ffb8-4d38-4d34-be80-126c532836b0
        - d10ae63f-b85f-4ea0-9e31-8937c3af3450
      allowed-skip:
        - b2e7ffb8-4d38-4d34-be80-126c532836b0
        - d10ae63f-b85f-4ea0-9e31-8937c3af3450
    do:
      type: evaluate
      options:
        - then:
            set-result: >
              {"status":{{ context["status"]}}}
    on:
      pre-do: #important to note that pre-do is decided before locking the step into one execution of DO (i.e. in-progress status)
        decisions:
          - label: check_access
          - label: check_valid_input
            input: >
              step_input:=request["data"]["status"]
        rules:
          - if: >
              result{decision["check_access"]["result"]=="denied"}
            then:
              error:
                code: 403
                message: "access denied"
                data: >
                  {{ decision["check_access"]["result"]}}
          - if: >
              result{decision["check_valid_input"]["result"]!="valid"}
            then:
              error:
                code: 400
                message: "invalid input"
                data: >
                  {{ decision["check_valid_input"]["result"]}}
      pre-done:
        decisions:
          - label: decision_step
            input: >
              step_status:=label["status"]
        rules:
          - if: >
              result{decision["decision_step"]["result"]="approved"}
            then:
              do:
                - label: path_1_step_2_email
                  context: >
                    {{ object.union(context,{"step":"path_1_step_2"}) }}
          - then:
              do:
                - label: report_run_result
                  context: >
                    { "result": "declined"}
  - name: "send emails to step path_1_step_2"
    description: >
      Send email by given step
    label: path_1_step_2_email
    do:
      type: REST # 201 with heartbeats of set InProgress and finaly set Done. 
      heartbeat-timeout: 180 # seconds. default 10. 
      options:
        timeout: 60
        method: GET
        url: >
          {{ env.flow}}/send-emails/path_1_step_2
        headers:
          authorization:
            - >
              {{ base64.encode(concat("privilegedUser:",  vault["privilegedUser path"])) }}
          tenant:
            - >
              {{ context["tenant"] }}
          namespace:
            - 351d87f0-9d4a-411b-9a98-7d55a9792eac
  - name: "Path 1 Step 2: role B"
    description: >
      this will be called as an event. I.e. we are awaiting for an external call (rest,command line etc...).
    label: path_1_step_2
    tags:
      allowed-approval:
        - b2e7ffb8-4d38-4d34-be80-126c532836b0
        - d10ae63f-b85f-4ea0-9e31-8937c3af3450
      allowed-skip:
        - b2e7ffb8-4d38-4d34-be80-126c532836b0
        - d10ae63f-b85f-4ea0-9e31-8937c3af3450
    do:
      type: evaluate
      options:
        - then:
            set-result: >
              {"status":{{ context["status"]}}}
    on:
      pre-do:
        decisions:
          - label: check_access
          - label: check_valid_input
            input: >
              step_input:=request["data"]["status"]
        rules:
          - if: >
              result{decision["check_access"]["result"]=="denied"}
            then:
              error:
                code: 403
                message: "access denied"
                data: >
                  {{ decision["check_access"]["result"]}}
          - if: >
              result{decision["check_valid_input"]["result"]!="valid"}
            then:
              error:
                code: 400
                message: "invalid input"
                data: >
                  {{ decision["check_valid_input"]["result"]}}
      pre-done:
        decisions:
          - label: decision_step
            input: >
              step_status:=label["status"]
        rules:
          - if: >
              result{decision["decision_step"]["result"]="approved"}
            then:
              do:
                - label: check_resolution
          - then:
              do:
                - label: report_run_result
                  context: >
                    { "result": "declined"}
  #.... path 2 path3....
  # last path do: report_run_result in the event of approved decision
  - name: Check Resolution
    label: check_resolution
    on:
      pre-do:
        decisions:
          - label: decision_resolution
            input: >
              path_1_step_1:=inputs["labels"]["path_1_step_1"]["status"]
              path_1_step_2:=inputs["labels"]["path_1_step_2"]["status"]
              path_2_step_1:=inputs["labels"]["path_2_step_1"]["status"]
              path_2_step_2:=inputs["labels"]["path_1_step_2"]["status"]
        rules:
          - if: >
              result{
                decision["decision_resolution"]["result"]=="approved"
              } else {
                decision["decision_resolution"]["result"]=="declined"
              }
            then:
              do:
                - label: report_run_result
                  context: >
                    { "result": {{ decision["decision_resolution"]["result"] }} }
          - then:
              abort: true #don't continue to "do"
  - name: Report Run Result
    label: report_run_result
    do:
      type: REST
      options:
        method: POST
        url: >
          {{ env.rulengine}}/re_notification
        body: >
          { "result": {{ context["result"] }} }
        headers:
          authorization:
            - >
              {{ base64.encode(concat("privilegedUser:",  vault["privilegedUser path"])) }}
          tenant:
            - >
              {{ context["tenant"] }}
          namespace:
            - 351d87f0-9d4a-411b-9a98-7d55a9792eac
    on:
      pre-done:
        rules:
          - if: >
              result{label["report_run_result"]["status"]!=200}
            then:
              set-run-status: done
              error:
                code: 500
                message: "failed"
                data: >
                  {{ label["report_run_result"]["status"] }}
          - then:
              set: # record this status in the step. label["report_run_result"]["kv"]["result"]
                - key: result
                  value: >
                    {{ context["result"] }}
              set-run-status: done #once run-status is "done" then no other processes can be executed in the run, and all existing are descarded.

#---------------------------------------------------------
decisions:
  - name: check access
    label: check_access # label must be unique
    rules:
      - if: >
          allowed-roles{context["roles"][_]==tags["allowed-approval"][_]}
          result{v:=["approve","decline"];context["status"]=v[_];not allowed-roles}
        then:
          result: denied
      - if: >
          allowed-roles{context["roles"][_]==tags["allowed-skipped"][_]}
          result{context["status"]="skipped";not allowed-roles}
        then:
          result: denied
  - name: check valid input
    label: check_valid_input
    attributes:
      - label: step_input
        type: flow_status
    rules:
      - then:
          result: valid
  - name: check a step has resolution
    label: decision_step # label must be unique
    attributes: # essentially these are both validation an if neccessary type conversion if possible.
      - label: step_status
        type: flow_status
    rules: # the IFs are first one true. we stop.
      - if: >
          result{v:=["skipped","approved"];step_status=v[_]}
        then:
          result: approved
      - if: >
          result{step_status="declined"}
        then:
          result: declined
  - name: check run has resolution
    label: decision_resolution
    attributes:
      - label: path_1_step_1
        type: flow_status
      - label: path_1_step_2
        type: flow_status
      - label: path_2_step_1
        type: flow_status
      - label: path_2_step_2
        type: flow_status
    dependencies:
      decisions:
        - label: decision_step
          as: path_1_step_1_decision
          input: >
            step_status:=path_1_step_1
        - label: decision_step
          as: path_1_step_2_decision
          input: >
            step_status:=path_1_step_2
        - label: decision_step
          as: path_2_step_1_decision
          input: >
            step_status:=path_2_step_1
        - label: decision_step
          as: path_2_step_2_decision
          input: >
            step_status:=path_2_step_2
    rules:
      - if: >
          result{
            v:=["skipped","approved"]
            path_1_step_1_decision["result"]=v[_]
            path_1_step_2_decision["result"]=v[_]
            path_2_step_1_decision["result"]=v[_]
            path_2_step_2_decision["result"]=v[_]
          }
        then:
          result: approved
      - if: >
          result{path_1_step_1_decision="declined"}
        then:
          result: declined
      - if: >
          result{path_1_step_2_decision="declined"}
        then:
          result: declined
      - if: >
          result{path_2_step_1_decision="declined"}
        then:
          result: declined
      - if: >
          result{path_2_step_2_decision="declined"}
        then:
          result: declined
concepts: # int64, float64 and string, bool are reserved and need not specified.
  - name: flow_status #unique name
    type: string
    validations:
      - >
        default result=false
        result{flow_status=="skipped"}else{flow_status=="approved"}else{flow_status=="declined"}

# notes:
# * as a convinience a response body is first attempted to be converted to a json. if it does not succeed it is stored as a string in the ["result"]["body"]
# * Vault secrets and properties (such as tenant properties) will be retrieved by default from a static text file or hashicorp vault client.
# * You can access environment variables via "env.".