title: "STEPSMAN Hello World"
# searchable tags. if you want to locate a template by an external key.
tags:
  uuid: e09d86c4-b907-4674-af4f-8aceeb2b7ef1
# a free form json which can contain additional information such as identifying or other info.
# when a run is created, they can be provided as overrides to the existing context or updated or per call when calling a step directly.
context: >
  {"app_id": 2 }
# validations are tested before and after each step calls do. before any other event (like on-done).
validations:
  - if: >
      time.now_ns()-(24*60*1000000000)>run["created_at"]
    then:
      set-run-result: '{"status":"failed"}'
      set-run-status: failed
steps:
  - name: Starting
    description: >
      Execute: echo "hello world" > stepsman_hello.world
    # overrides the template/run level context
    # a free form json which can contain additional information such as identifying or other info.
    # when a run is created, they can be provided as overrides to the existing context or updated or per call when calling a step directly.
    context: >
      {"step_id": 2 }
    label: hello #unique identifier for the step.
    do:
      options:
        command: "/bin/sh"
        arguments:
          - "-c"
          - 'echo "Hello World" > stepsman_hello.world'
  - name: "Call REST API"
    description: >
      check that stepshello.world was created via rest
    label: call_rest
    do:
      type: REST # 200 is synchronous done, 201 means asynchronous process(InProgress)
      # the callee is supposed to perform heartbeats (PUT InProgress) and set resolution: Done, Failed
      # any other http status is an automatic fail.
      timeout: 180 # seconds. default 60. if the callee
      options:
        map-response-status:
          - 201: done # when you want to override the default.
          - _: done # example of how all http statuses are translated to done so it will always succeed.
        method: POST
        body: >
          {}
        headers:
          authorization: >
            base64.encode(concat("privilegedUser:", "{{ vault["privilegedUser"] }}"))
    on:
      set-done:
        decision: "check label success and do another step"
        rules:
          - if: >
              decision["result"]=="rollback"
            then:
              do:
                - end
          - then:
              set-run-status: failed
              #optional: just for demonstration of return error code if this was a rest call
              return-error:
                code: 1
                message: "return to the previous state"
                data: >
                  {{ decision["result" ]}}
          - if: >
              decision["result"]=="next"
            then:
              #optional: just for demonstration of return a successful result if this was a rest call
              return-result: "success"
  - name: "end of run"
    label: end

#---------------------------------------------------------
decisions:
  # example input for a decision
  #{
  #"input": {
  #  "labels": {
  #      "hello": {
  #          "exit-code": 0
  #          }
  #      }
  #  }
  #}
  - name: "check label success and do another step"
    label: decision_1 # label must be unique
    attributes:
      - exit:
          # the current label content is available in input
          _: >
            input["exit-code"]
          type: int64 #one of the built-in types.
      - degrees:
          # all the labels are available in inputs
          _: >
            inputs["labels"]["call_rest"]["result"]["body"]["degrees"]
          type: degree # a concept allows for validation before deciding. validation fail, means the attribute will be evaluated as undefined internally.
    #rules-options: #optional
    #  order: "first" # default is first. However, it can be "all" which means all "if"s will be evaluated.
    rules:
      - if: # "_" is a short for expression, "_s" is a short for multiple expressions (like multi-value, depends on the op). op is a short for operator.
          # the list expressions are "ANDed"
          - _: "result{exit>-3;exit<1}"
          - _: "exit>-3 && exit==0"
            op: "js-es5" # javascript operator - evalues the expression in a simple es5 interpreter
          - _: "0" # alternative notation
            attribute: exit
            op: =
          - attribute: degrees #a convinience, same as: degree=="bsc" || degree=="msc"
            op: =
            _s: # example for multi expression. In this case, multi-value evaluation.
              - bsc
              - msc
            # custom functions are memoized by default
          - _: >
              mlinference("0", exit)>3
        then:
          result: rollback #simply assigns to an attribute called do the value "rollback"
      - then: #fallback/default rule, "if" is defaulted to true if unspecified
          result: next
concepts: # int64, float64 and string, bool are reserved and need not specified.
  - name: degree #unique name
    type: string
    validations:
      - >
        result{degree=="bsc"}else{degree=="msc"}
functions:
  - name: mlinference
    type: externa-ml # can be plugged-in
    #memoized: true by default

# notes:
# * cyclic calls are not allowed.
# * The cursor is a helpful aid but is not mandatory. Interactive mode usually benefits from it.
# * A run and its steps state is stored in a database so it is important not to strain it by storing huge amounts of data since it is loaded for each step.
# * run state: not started, stopping, stopped, in progress, done (done must be specified by a step and is not automatic)
# * You can only "do" a step from a stopped position unless done. So, if it was done or in-progress, it stays done and returns conflict (409),
#   if it is canceled/stopped, failed, skipped, not started it can be restarted and its state is erased and returns 201.
#   You can also change a step from a running state to a stopped state and then restart it.
#   step states: not started, stopping, stopped, failed, in progress, skipped, done.
#   Important to note that if a step schedueled another step to start then it cannot be stopped unless the run is currently stopped and reset (if started again without a reset it will continue)
#   Another possiblity is to put a validation on the run that will make sure older scheduled steps will retire.
#   There will probably be an atomic operations series that will be transactional such as reset and start.
# * future: it is possible to generate a streaming process providing a multi-line. E.g. If a command line process prints a ndjson
#   or a json list we can read it line by line and the next step will start receiving it and doing it even before the current step is over. When finished the current step will be done.
#   and the next step will be done as soon as it finished processing the steps. Important to note, that the next step will fail if any line fails as a whole. i.e. there are only unique steps not multiples.
#   it is also possible that behind the scenes they will run concurrently but their final state will be considered as a whole.
# * as a convinience a response body is first attempted to be converted to a json. if it does not succeed it is stored as a string in the ["result"]["body"]
# * you can register a webhook for notifications. So for example, you can register a specific run or all runs for notifications for some or all events.
#   alternatively or on top of it, we can consider supporting a queue/topic like for notifications. We can start with redis pub/sub
# * Quite obviously you will be able to query the state and all information via a REST API.
# * Future: A security system to guard the APIs will be in place. Quite possibly connected to an external or internal OPA.
#   Every step should be contained in an Audit trail so a history mechanism will be in place. Quite possibly a syslog audit log or file.
# * To have an ability for a kind of atomic operations. A run with a name and inprogress status cannot be created with the same name (of the run not the title of the template).
#   So that when a run can be run only one concurrently then this will throw an error if the run is created. You can cancel the run by making a stop request on it.
#   Once stopped, you can reset all or a specific step and start the run.
# * A run contains a reference to a specific version of a template so that once created a modification to the actual template has no effect on the run.
# * Tags can be set also when creating a run which will override existing tag names (from the template)
# * The serve restapi will be a json-rpc style with 1 endpoint. /v0/json-rpc
# * Important to note that a decision should not have side effects. If you do, then you have to understand that if you set-done event asynchronously concurrently then only one
#   will take effect. It will set-done with a transaction, and only then execute the "then" clauses. if it will detect that the status is already done, you will get an error back,
#   which is ok to ignore if, for example, it was caused by unaware callers (such as a link from a bunch of emails like in approvals process).
# * Vault secrets and properties (such as tenant properties) will be retrieved by default from a static text file or hashicorp vault client.
# * You can access environment variables via "env.".